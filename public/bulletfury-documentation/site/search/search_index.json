{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Bulletfury \u00b6 Hi! Bulletfury is a high-performance 2D bullet spawning and rendering framework for Unity. Whether you're making a chaotic bullet hell or just need a few projectiles for your platformer, this tool is designed to make it easy, fast, and fun. Compatibility \u00b6 Just a quick heads-up on what you'll need: Unity 6 or newer URP (Universal Render Pipeline) How to use these docs \u00b6 We've set things up to get you moving quickly: Getting Started : We'll walk you through installing the package and getting your first bullets on screen. Modules : Learn about the building blocks of Bulletfury and how to snap them together. Patterns : We've got some recipes for common bullet patterns to help you get started. Custom Modules : Want to do something unique? We'll show you how to write your own modules. API Reference : Full type/member reference with usage notes and best practices. Is this for you? \u00b6 If you're building a shooter, a bullet hell game, or anything that needs a lot of projectiles, then yes! Bulletfury is perfect for: Designers who want to tweak bullet behavior right in the Inspector without touching code. Programmers who want a solid foundation to build custom bullet logic on top of. Teams who want a shared language for defining bullet patterns. Where to go next \u00b6 Setup and First Spawn : The best place to start. Get the package installed and fire your first shot. API Reference : Detailed code-level docs for all public types and extension points. Free Modules : See what tools are in your toolbox right now. Basic Patterns : Learn by example with some classic bullet patterns. Write Your Own Modules : Dive into the code and make Bulletfury do exactly what you need. Quick links \u00b6 UPM Package Name : com.wayfarergames.bulletfury Paid Version : Check out the Paid Version page if you're interested in the advanced features.","title":"Home"},{"location":"#welcome-to-bulletfury","text":"Hi! Bulletfury is a high-performance 2D bullet spawning and rendering framework for Unity. Whether you're making a chaotic bullet hell or just need a few projectiles for your platformer, this tool is designed to make it easy, fast, and fun.","title":"Welcome to Bulletfury"},{"location":"#compatibility","text":"Just a quick heads-up on what you'll need: Unity 6 or newer URP (Universal Render Pipeline)","title":"Compatibility"},{"location":"#how-to-use-these-docs","text":"We've set things up to get you moving quickly: Getting Started : We'll walk you through installing the package and getting your first bullets on screen. Modules : Learn about the building blocks of Bulletfury and how to snap them together. Patterns : We've got some recipes for common bullet patterns to help you get started. Custom Modules : Want to do something unique? We'll show you how to write your own modules. API Reference : Full type/member reference with usage notes and best practices.","title":"How to use these docs"},{"location":"#is-this-for-you","text":"If you're building a shooter, a bullet hell game, or anything that needs a lot of projectiles, then yes! Bulletfury is perfect for: Designers who want to tweak bullet behavior right in the Inspector without touching code. Programmers who want a solid foundation to build custom bullet logic on top of. Teams who want a shared language for defining bullet patterns.","title":"Is this for you?"},{"location":"#where-to-go-next","text":"Setup and First Spawn : The best place to start. Get the package installed and fire your first shot. API Reference : Detailed code-level docs for all public types and extension points. Free Modules : See what tools are in your toolbox right now. Basic Patterns : Learn by example with some classic bullet patterns. Write Your Own Modules : Dive into the code and make Bulletfury do exactly what you need.","title":"Where to go next"},{"location":"#quick-links","text":"UPM Package Name : com.wayfarergames.bulletfury Paid Version : Check out the Paid Version page if you're interested in the advanced features.","title":"Quick links"},{"location":"api-reference/","text":"API Reference \u00b6 This page documents the public API surface in com.wayfarergames.bulletfury as it exists in the package source. It is written for developers who want exact names, expected behavior, and practical usage guidance. What this reference covers \u00b6 Runtime APIs you are expected to use directly ( BulletSpawner , module interfaces, data models, events). Built-in free modules in Bulletfury.Modules . Rendering/data types that are public and available from code. Advanced/low-level public types that exist but are usually engine-internal for Bulletfury operation. Namespaces \u00b6 Bulletfury : spawner, modules interfaces, core config/data classes. Bulletfury.Data : bullet container/event/enums used by runtime and modules. Bulletfury.Modules : built-in free modules. Common and Common.FloatOrRandom : random/value helper types used by Bulletfury. Wayfarer_Games.Common and Wayfarer_Games.Common.FloatOrRandom : utility/random helper namespaces exposed by the package. BulletSpawner \u00b6 BulletSpawner is the main entry point. It owns bullet simulation, module execution, collision checks, and render queue submission. Type \u00b6 Bulletfury.BulletSpawner : MonoBehaviour Public properties \u00b6 SharedRenderData RenderData - Active render config (inline or shared ScriptableObject). BulletMainData Main - Bullet simulation settings (fire mode, speed, lifetime, collision profile, etc). SpawnShapeData SpawnShapeData - Spawn positions and initial direction generation config. BurstData BurstData - Burst sequencing and active bullet cap config. float LastSimulationDeltaTime - Last simulation step delta from runtime module. int BulletCount - Current number of active bullets. bool Disposed - Whether native buffers were disposed. static SortedList<float, RenderQueueData> RenderQueue - Global queue consumed by BulletRenderer . Public events \u00b6 event Action<BulletContainer, bool> OnBulletDiedEvent bool indicates end-of-life ( true ) vs collision death ( false ). event Action<int, BulletContainer> OnBulletSpawnedEvent Invoked after bullet init and module bootstrapping. event Action OnWeaponFiredEvent Invoked when a spawn sequence starts. Public methods \u00b6 Lifecycle/control: void Start() void OnDestroy() void Stop() void Play() void SetSimulationPaused(bool paused) void EnsureSimulationInitialized() void ClearBullets() void RenderBulletsNow() void UpdateAllBullets(Camera cam, float? dt = null) bool CheckBulletsRemaining() void ActivateWaitingBullets() Preset/state: void SetPreset(BulletSpawnerPreset preset) SpawnerState CaptureState(SpawnerState reusableState = null) void ApplyState(SpawnerState state) Spawning: void Spawn(Vector3 position, Vector3 up, float deltaTime) void SpawnImmediate(Vector3 position, Vector3 up, float deltaTime) void Spawn(Transform obj, float deltaTime) Module retrieval: T GetModule<T>() where T : IBaseBulletModule bool TryGetModule<T>(out T module) where T : IBaseBulletModule List<T> GetModulesOfType<T>() where T : IBaseBulletModule void GetModulesOfType<T>(List<T> output) where T : IBaseBulletModule Nested public types \u00b6 BulletSpawner.RenderQueueData BulletRenderData RenderData Camera Camera int Count NativeArray<Matrix4x4> Transforms NativeArray<float4> Colors NativeArray<float> Times BulletSpawner Spawner BulletSpawner.SpawnerState Snapshot payload used by CaptureState / ApplyState . Includes bullet array, spawn scheduling internals, and runtime module state. Usage example: manual firing \u00b6 using Bulletfury; using UnityEngine; public class PlayerGun : MonoBehaviour { [SerializeField] private BulletSpawner spawner; private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { // Uses this transform's current position and up direction. spawner.Spawn(transform.position, transform.up, Time.deltaTime); } } } Usage example: save/load spawner simulation \u00b6 using Bulletfury; using UnityEngine; public class SpawnerStateController : MonoBehaviour { [SerializeField] private BulletSpawner spawner; private BulletSpawner.SpawnerState state; public void Save() { state = spawner.CaptureState(state); } public void Load() { if (state != null) spawner.ApplyState(state); } } Best practices \u00b6 Call EnsureSimulationInitialized() before doing custom state operations early in lifecycle. Use SpawnImmediate(...) only for event-driven cases where you intentionally bypass fire-rate timing. Prefer TryGetModule<T> for optional modules; use GetModule<T> only when module presence is guaranteed. Call ClearBullets() when changing high-level pattern presets at runtime to avoid mixed old/new behavior. Use SetSimulationPaused(true) if you want to freeze simulation but keep rendering live. Module interfaces and contracts \u00b6 These are the extension points for custom behavior. IBulletHitHandler \u00b6 Signature: void Hit(BulletContainer bullet) Implement on collider hierarchies to receive collision callbacks queued by BulletSpawner . IBaseBulletModule \u00b6 Marker interface for all module categories. IBulletSpawnModule \u00b6 Signature: void Execute(ref Vector3 position, ref Quaternion rotation, float deltaTime) Runs during spawn position/orientation generation, before bullet is created. IBulletInitModule \u00b6 Signature: void Execute(ref BulletContainer container) Runs once per bullet at creation. IBulletModule \u00b6 Signature: void Execute(ref BulletContainer container, float deltaTime) Runs during simulation update. IParallelBulletModule \u00b6 Marker interface that opts an IBulletModule into parallel execution ( Parallel.For ). Keep logic pure math/data only; no Unity API calls, scene access, allocations, or mutable shared state. IBulletDieModule \u00b6 Signature: CollisionBehaviour Execute(ref BulletContainer container, bool isCollision, GameObject collidingObject) Enum: CollisionBehaviour.Dies CollisionBehaviour.StaysAlive Called when a bullet would die from collision or end-of-life; return StaysAlive to cancel death. Runtime module interfaces (advanced) \u00b6 ISpawnerRuntimeModule float LastSimulationDeltaTime { get; } void OnRuntimeReset(Squirrel3 random) void OnSimulationStep(float deltaTime) float Sample(FloatOrRandom value, Squirrel3 random) object CaptureState() void RestoreState(object state) ISpawnerRuntimeModuleProvider : IBaseBulletModule ISpawnerRuntimeModule CreateRuntimeModule() Use runtime modules when you need custom deterministic value sampling/state progression for spawner-level behavior. Custom module template \u00b6 using System; using Bulletfury; using Bulletfury.Data; using UnityEngine; namespace MyGame.Modules { [Serializable] [ModuleDescription(\"Adds a constant lateral drift.\")] [ModulePerformanceImpact(ModulePerformanceImpactRating.Low)] public class SideDriftModule : IBulletModule, IParallelBulletModule { [SerializeField] private float drift = 1f; public void Execute(ref BulletContainer container, float deltaTime) { container.Position += container.Right * drift * deltaTime; } } } Core configuration types \u00b6 BulletMainData \u00b6 FireMode FireMode ( Automatic , Manual ) bool PlayOnEnable FloatOrRandom FireRate FloatOrRandom Damage FloatOrRandom Lifetime FloatOrRandom Speed Color StartColor FloatOrRandom StartSize bool UseRotationForDirection bool MoveWithTransform bool RotateWithTransform ColliderType ColliderType ( Circle , Capsule ) float ColliderSize (0..1) float CapsuleLength (0..1) SpawnShapeData \u00b6 SpawnDir spawnDir int numPoints int numPerSide int numPerGroup FloatOrRandom groupRadius bool spawnCentreBullet bool groupDirection float removeFromEdgePercent FloatOrRandom radius FloatOrRandom arc bool randomise bool onEdge FloatOrRandom directionArc void Spawn(Action<Vector2, Vector2> onGetPoint, Squirrel3 rnd) Spawn(...) computes all spawn positions and direction vectors based on shape/arc/group settings and invokes callback per spawn point. BurstData \u00b6 float delay int maxActiveBullets ( 0 = uncapped, internally clamped by spawner storage capacity) int burstCount float burstDelay float stackSpeedIncrease bool burstsUpdatePositionEveryBullet BulletSpawnerPreset : ScriptableObject \u00b6 bool UseMain BulletMainData Main bool UseShape SpawnShapeData ShapeData bool UseBurstData BurstData BurstData bool UseModules List<IBaseBulletModule> BulletModules Apply at runtime with BulletSpawner.SetPreset(...) . Bullet data model ( Bulletfury.Data ) \u00b6 BulletContainer fields \u00b6 Identity: int Id Transform and orientation: float3 Position Quaternion Rotation Quaternion Direction float3 Forward float3 Right float3 Up Visual: Color Color Color StartColor float StartSize float CurrentSize Collision: float ColliderSize byte UseCapsule float CapsuleLength byte Collided Lifetime/state: float Lifetime float CurrentLifeSeconds float CurrentLifePercent byte Dead byte EndOfLife byte Waiting float TimeToWait Movement and gameplay: float Speed float CurrentSpeed float3 Velocity float3 Force float AngularVelocity float Damage Move-to-origin behavior: byte MovingToOrigin float3 OriginPosition float MoveToOriginTime float MoveToOriginCurrentTime float3 MoveToOriginStartPosition Method: void InitWithPositionRotationDirection(float3 position, Quaternion rotation, Quaternion direction) Data enums \u00b6 SpawnDir : Shape , Randomised , Spherised , Direction , Point ForceSpace : Local , World CurveUsage : Lifetime , LoopedTime Event types \u00b6 BulletSpawnedEvent : UnityEvent<int, BulletContainer> BulletDiedEvent : UnityEvent<int, BulletContainer, bool> BulletCancelledEvent : UnityEvent<int, BulletContainer, bool> BulletCollisionEvent : UnityEvent<BulletContainer, Transform> Rendering and shared render data \u00b6 BulletRenderData \u00b6 Public fields: Camera Camera Texture2D Texture bool Animated int Rows int Columns float PerFrameLength int Layer int Priority Public members: Material Material { get; } static void ResetMaterials() Material GetMaterial() void ReturnMaterial(Material material) void DisposeMaterials() SharedRenderData \u00b6 BulletRenderData Data { get; } SharedRenderDataSO SharedDataSO { get; } (editor-only) Implicit conversions: SharedRenderData -> BulletRenderData BulletRenderData -> SharedRenderData SharedRenderDataSO -> SharedRenderData SharedRenderDataSO : ScriptableObject \u00b6 void SetData(BulletRenderData data) Implicit conversion: SharedRenderDataSO -> BulletRenderData BulletRenderer (advanced static renderer API) \u00b6 Mesh Mesh { get; } static void Init() static void Dispose() static void Render(BulletRenderData data, NativeArray<Matrix4x4> transforms, NativeArray<float4> colors, NativeArray<float> times, int numBullets, Camera cam) Most users should not call BulletRenderer.Render(...) manually. Use BulletSpawner unless building a custom render path. Built-in free modules ( Bulletfury.Modules ) \u00b6 AngularVelocityModule : BulletModule, IParallelBulletModule \u00b6 Purpose: rotates bullet orientation over time. Serialized fields: AnimationCurve angularVelocity float scale BulletColorOverTimeModule : BulletModule \u00b6 Purpose: applies gradient over life or looped time. Fields: Gradient colorOverTime BulletDamageOverTimeModule : IBulletModule, IParallelBulletModule \u00b6 Purpose: scales BulletContainer.Damage . Fields: AnimationCurve damageOverTime BulletSizeOverTimeModule : BulletModule, IParallelBulletModule \u00b6 Purpose: scales size over time. Fields: AnimationCurve sizeOverTime SpeedOverTimeModule : BulletModule, IParallelBulletModule \u00b6 Purpose: scales current speed over time. Serialized fields: AnimationCurve speedOverTime float scale SpawnerRotateModule : IBulletSpawnModule \u00b6 Purpose: continuously rotates spawn basis at emit time. Serialized fields: float angularSpeed Public property: float CurrentAngle { get; } WaitToContinueModule : IBulletInitModule \u00b6 Purpose: mark bullets as waiting after a configured pre-wait simulation time. Serialized fields: float timeToPlayBeforeWaiting Works with BulletSpawner.ActivateWaitingBullets() . Premium add-on modules ( Bulletfury.Modules ) \u00b6 These types are in the premium package ( Bulletfury.Premium ) and are not part of the free module set. AimedShotModule : IBulletSpawnModule \u00b6 Re-aims spawn rotation toward a target before emission. Supports multiple aim modes via AimType : Instant , Linear , Slerp , SmoothDamp , Predicted . Public method: void SetTarget(Transform newTarget) TrackObjectModule : BulletModule \u00b6 Continuously steers active bullets toward a tracked transform over lifetime. Public properties: Transform ToTrack { get; } float TurnSpeed { get; } BulletBounceModule : IBulletDieModule \u00b6 Intercepts collision death and reflects bullet direction/velocity for ricochet behavior. Can filter by collider tag and scale speed/lifetime per bounce. ForceOverTimeModule : BulletModule, IParallelBulletModule \u00b6 Applies curve-driven forces over bullet lifetime. Key options: ForceSpace space ( Local / World ) Vector3 scale AnimationCurve forceOverTimeX/Y/Z SinWaveOffsetModule : BulletModule, IParallelBulletModule \u00b6 Adds sinusoidal lateral offset to bullet trajectory over time. Key controls include amplitude, frequency, phase offset, direction invert, and amplitude curve. SpawnFromTransformModule : IBulletInitModule \u00b6 Spawns bullets from a referenced transform and interpolates toward original spawn position. SubSpawnerModule : IBulletDieModule \u00b6 Emits configured sub-spawners on collision and/or end-of-life events. Uses SubSpawnerData[] payload configuration. ReplayModule : IBaseBulletModule \u00b6 Records BulletSpawner.SpawnerState snapshots over time for playback/rewind flows. Key methods: void RecordStep(BulletSpawner spawner, float deltaTime) void ResetTimeline() void PrepareForRewind(BulletSpawner spawner) void TrimFutureSteps() bool TryRewindBySeconds(float rewindSeconds, out float actualSecondsRewound) bool TryGetAppliedState(out BulletSpawner.SpawnerState state) RewindModule : IBaseBulletModule \u00b6 Applies rewind playback against a ReplayModule timeline. Key methods: void BeginRewind() void EndRewind() bool Rewind(BulletSpawner spawner, ReplayModule replayModule, float deltaTime) DeterministicRuntimeModule : ISpawnerRuntimeModuleProvider, ISpawnerRuntimeModule, IBulletInitModule \u00b6 Installs deterministic random sampling/tick stepping into spawner runtime. Public members: ulong Tick { get; } float LastSimulationDeltaTime { get; } ISpawnerRuntimeModule CreateRuntimeModule() void OnRuntimeReset(Squirrel3 random) void OnSimulationStep(float deltaTime) float Sample(FloatOrRandom value, Squirrel3 random) object CaptureState() void RestoreState(object state) void Execute(ref BulletContainer container) SubSpawnerData (premium data model) \u00b6 bool emitOnCollide bool emitOnLifeEnd bool inheritRotation bool inheritColor BulletSpawner spawner Attributes and metadata \u00b6 ModulePerformanceImpactRating \u00b6 Low , Medium , High , VeryHigh ModulePerformanceImpactAttribute \u00b6 Constructors: ModulePerformanceImpactAttribute(ModulePerformanceImpactRating rating) ModulePerformanceImpactAttribute(ModulePerformanceImpactRating rating, string justification) Properties: ModulePerformanceImpactRating Rating { get; } string Justification { get; } ModuleDescriptionAttribute \u00b6 Constructor: ModuleDescriptionAttribute(string description) Property: string Description { get; } Use these on custom modules to improve inspector discoverability and team readability. Common/random utility APIs \u00b6 These are public in the package and often useful in custom runtime/module code. Common.FloatOrRandom.FloatOrRandom \u00b6 float Value { get; } float GetValue(Squirrel3 rnd) Implicit conversion: FloatOrRandom -> float float -> FloatOrRandom Wayfarer_Games.Common.FloatOrRandom.IntOrRandom \u00b6 int Value { get; } int GetValue(Squirrel3 rnd) Implicit conversion: IntOrRandom -> int int -> IntOrRandom Common.Squirrel3 \u00b6 Constructors: Squirrel3() Squirrel3(int seed) Static: Squirrel3 Instance State: readonly struct State void SetSeed(int seed) void ResetState() State CaptureState() void RestoreState(State state) Sampling: float Next() double NextDouble() Vector2 RandomPointInUnitCircle() float Range(float min, float max) double Range(double min, double max) int Range(int min, int max) bool Bool() bool Bool(float chance) bool Bool(double chance) Selection: T WeightedRandom<T>(Dictionary<T, float> items) where T : class T WeightedRandom<T>(List<T> items) where T : class, IWeightedItem T GetRandomElement<T>(IEnumerable<T> list, out int idx) Common.IWeightedItem \u00b6 float Weight { get; } Wayfarer_Games.Common.QuaternionUtil \u00b6 Quaternion AngVelToDeriv(Quaternion current, Vector3 angVel) Vector3 DerivToAngVel(Quaternion current, Quaternion deriv) Quaternion IntegrateRotation(Quaternion rotation, Vector3 angularVelocity, float deltaTime) Quaternion SmoothDamp(Quaternion rot, Quaternion target, ref Quaternion deriv, float time, float deltaTime) Low-level/advanced public types \u00b6 BulletJob : IJobParallelFor \u00b6 BulletJob is public, but primarily intended for internal scheduling from BulletSpawner . Public fields include bullet arrays, render output arrays, transform deltas, collision sizing, and feature toggles ( UseRotationForDirection , MoveWithTransform , RotateWithTransform ). Public method: void Execute(int index) Unless you are building a custom simulation runner, use BulletSpawner.UpdateAllBullets(...) rather than scheduling BulletJob yourself. Best practices and pitfalls \u00b6 Keep module logic deterministic and side-effect free where possible. For IParallelBulletModule , do not call Unity object APIs ( Transform , scene queries, physics, object creation/destruction). Treat BulletContainer as mutable state for the current step only; initialize all values you depend on. Use TryGetModule<T> and null checks in gameplay code that supports optional module loadouts. Keep maxActiveBullets tuned; uncapped ( 0 ) can still hit internal limits depending on spawner capacity. Prefer circle colliders for throughput; capsule colliders are heavier. If using CaptureState/ApplyState , keep module composition stable between save/load to avoid semantic mismatches. Recommended testing checklist \u00b6 Verify FireMode.Automatic and FireMode.Manual behaviors independently. Validate module behavior with and without IParallelBulletModule . Test collision and end-of-life death paths separately (including custom IBulletDieModule cancellation). Test pause/resume ( SetSimulationPaused ) and waiting bullets ( ActivateWaitingBullets ). If you rely on replay/state restore, test deterministic capture/restore over multiple seconds under varying frame rates.","title":"API Reference"},{"location":"api-reference/#api-reference","text":"This page documents the public API surface in com.wayfarergames.bulletfury as it exists in the package source. It is written for developers who want exact names, expected behavior, and practical usage guidance.","title":"API Reference"},{"location":"api-reference/#what-this-reference-covers","text":"Runtime APIs you are expected to use directly ( BulletSpawner , module interfaces, data models, events). Built-in free modules in Bulletfury.Modules . Rendering/data types that are public and available from code. Advanced/low-level public types that exist but are usually engine-internal for Bulletfury operation.","title":"What this reference covers"},{"location":"api-reference/#namespaces","text":"Bulletfury : spawner, modules interfaces, core config/data classes. Bulletfury.Data : bullet container/event/enums used by runtime and modules. Bulletfury.Modules : built-in free modules. Common and Common.FloatOrRandom : random/value helper types used by Bulletfury. Wayfarer_Games.Common and Wayfarer_Games.Common.FloatOrRandom : utility/random helper namespaces exposed by the package.","title":"Namespaces"},{"location":"api-reference/#bulletspawner","text":"BulletSpawner is the main entry point. It owns bullet simulation, module execution, collision checks, and render queue submission.","title":"BulletSpawner"},{"location":"api-reference/#type","text":"Bulletfury.BulletSpawner : MonoBehaviour","title":"Type"},{"location":"api-reference/#public-properties","text":"SharedRenderData RenderData - Active render config (inline or shared ScriptableObject). BulletMainData Main - Bullet simulation settings (fire mode, speed, lifetime, collision profile, etc). SpawnShapeData SpawnShapeData - Spawn positions and initial direction generation config. BurstData BurstData - Burst sequencing and active bullet cap config. float LastSimulationDeltaTime - Last simulation step delta from runtime module. int BulletCount - Current number of active bullets. bool Disposed - Whether native buffers were disposed. static SortedList<float, RenderQueueData> RenderQueue - Global queue consumed by BulletRenderer .","title":"Public properties"},{"location":"api-reference/#public-events","text":"event Action<BulletContainer, bool> OnBulletDiedEvent bool indicates end-of-life ( true ) vs collision death ( false ). event Action<int, BulletContainer> OnBulletSpawnedEvent Invoked after bullet init and module bootstrapping. event Action OnWeaponFiredEvent Invoked when a spawn sequence starts.","title":"Public events"},{"location":"api-reference/#public-methods","text":"Lifecycle/control: void Start() void OnDestroy() void Stop() void Play() void SetSimulationPaused(bool paused) void EnsureSimulationInitialized() void ClearBullets() void RenderBulletsNow() void UpdateAllBullets(Camera cam, float? dt = null) bool CheckBulletsRemaining() void ActivateWaitingBullets() Preset/state: void SetPreset(BulletSpawnerPreset preset) SpawnerState CaptureState(SpawnerState reusableState = null) void ApplyState(SpawnerState state) Spawning: void Spawn(Vector3 position, Vector3 up, float deltaTime) void SpawnImmediate(Vector3 position, Vector3 up, float deltaTime) void Spawn(Transform obj, float deltaTime) Module retrieval: T GetModule<T>() where T : IBaseBulletModule bool TryGetModule<T>(out T module) where T : IBaseBulletModule List<T> GetModulesOfType<T>() where T : IBaseBulletModule void GetModulesOfType<T>(List<T> output) where T : IBaseBulletModule","title":"Public methods"},{"location":"api-reference/#nested-public-types","text":"BulletSpawner.RenderQueueData BulletRenderData RenderData Camera Camera int Count NativeArray<Matrix4x4> Transforms NativeArray<float4> Colors NativeArray<float> Times BulletSpawner Spawner BulletSpawner.SpawnerState Snapshot payload used by CaptureState / ApplyState . Includes bullet array, spawn scheduling internals, and runtime module state.","title":"Nested public types"},{"location":"api-reference/#usage-example-manual-firing","text":"using Bulletfury; using UnityEngine; public class PlayerGun : MonoBehaviour { [SerializeField] private BulletSpawner spawner; private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { // Uses this transform's current position and up direction. spawner.Spawn(transform.position, transform.up, Time.deltaTime); } } }","title":"Usage example: manual firing"},{"location":"api-reference/#usage-example-saveload-spawner-simulation","text":"using Bulletfury; using UnityEngine; public class SpawnerStateController : MonoBehaviour { [SerializeField] private BulletSpawner spawner; private BulletSpawner.SpawnerState state; public void Save() { state = spawner.CaptureState(state); } public void Load() { if (state != null) spawner.ApplyState(state); } }","title":"Usage example: save/load spawner simulation"},{"location":"api-reference/#best-practices","text":"Call EnsureSimulationInitialized() before doing custom state operations early in lifecycle. Use SpawnImmediate(...) only for event-driven cases where you intentionally bypass fire-rate timing. Prefer TryGetModule<T> for optional modules; use GetModule<T> only when module presence is guaranteed. Call ClearBullets() when changing high-level pattern presets at runtime to avoid mixed old/new behavior. Use SetSimulationPaused(true) if you want to freeze simulation but keep rendering live.","title":"Best practices"},{"location":"api-reference/#module-interfaces-and-contracts","text":"These are the extension points for custom behavior.","title":"Module interfaces and contracts"},{"location":"api-reference/#ibullethithandler","text":"Signature: void Hit(BulletContainer bullet) Implement on collider hierarchies to receive collision callbacks queued by BulletSpawner .","title":"IBulletHitHandler"},{"location":"api-reference/#ibasebulletmodule","text":"Marker interface for all module categories.","title":"IBaseBulletModule"},{"location":"api-reference/#ibulletspawnmodule","text":"Signature: void Execute(ref Vector3 position, ref Quaternion rotation, float deltaTime) Runs during spawn position/orientation generation, before bullet is created.","title":"IBulletSpawnModule"},{"location":"api-reference/#ibulletinitmodule","text":"Signature: void Execute(ref BulletContainer container) Runs once per bullet at creation.","title":"IBulletInitModule"},{"location":"api-reference/#ibulletmodule","text":"Signature: void Execute(ref BulletContainer container, float deltaTime) Runs during simulation update.","title":"IBulletModule"},{"location":"api-reference/#iparallelbulletmodule","text":"Marker interface that opts an IBulletModule into parallel execution ( Parallel.For ). Keep logic pure math/data only; no Unity API calls, scene access, allocations, or mutable shared state.","title":"IParallelBulletModule"},{"location":"api-reference/#ibulletdiemodule","text":"Signature: CollisionBehaviour Execute(ref BulletContainer container, bool isCollision, GameObject collidingObject) Enum: CollisionBehaviour.Dies CollisionBehaviour.StaysAlive Called when a bullet would die from collision or end-of-life; return StaysAlive to cancel death.","title":"IBulletDieModule"},{"location":"api-reference/#runtime-module-interfaces-advanced","text":"ISpawnerRuntimeModule float LastSimulationDeltaTime { get; } void OnRuntimeReset(Squirrel3 random) void OnSimulationStep(float deltaTime) float Sample(FloatOrRandom value, Squirrel3 random) object CaptureState() void RestoreState(object state) ISpawnerRuntimeModuleProvider : IBaseBulletModule ISpawnerRuntimeModule CreateRuntimeModule() Use runtime modules when you need custom deterministic value sampling/state progression for spawner-level behavior.","title":"Runtime module interfaces (advanced)"},{"location":"api-reference/#custom-module-template","text":"using System; using Bulletfury; using Bulletfury.Data; using UnityEngine; namespace MyGame.Modules { [Serializable] [ModuleDescription(\"Adds a constant lateral drift.\")] [ModulePerformanceImpact(ModulePerformanceImpactRating.Low)] public class SideDriftModule : IBulletModule, IParallelBulletModule { [SerializeField] private float drift = 1f; public void Execute(ref BulletContainer container, float deltaTime) { container.Position += container.Right * drift * deltaTime; } } }","title":"Custom module template"},{"location":"api-reference/#core-configuration-types","text":"","title":"Core configuration types"},{"location":"api-reference/#bulletmaindata","text":"FireMode FireMode ( Automatic , Manual ) bool PlayOnEnable FloatOrRandom FireRate FloatOrRandom Damage FloatOrRandom Lifetime FloatOrRandom Speed Color StartColor FloatOrRandom StartSize bool UseRotationForDirection bool MoveWithTransform bool RotateWithTransform ColliderType ColliderType ( Circle , Capsule ) float ColliderSize (0..1) float CapsuleLength (0..1)","title":"BulletMainData"},{"location":"api-reference/#spawnshapedata","text":"SpawnDir spawnDir int numPoints int numPerSide int numPerGroup FloatOrRandom groupRadius bool spawnCentreBullet bool groupDirection float removeFromEdgePercent FloatOrRandom radius FloatOrRandom arc bool randomise bool onEdge FloatOrRandom directionArc void Spawn(Action<Vector2, Vector2> onGetPoint, Squirrel3 rnd) Spawn(...) computes all spawn positions and direction vectors based on shape/arc/group settings and invokes callback per spawn point.","title":"SpawnShapeData"},{"location":"api-reference/#burstdata","text":"float delay int maxActiveBullets ( 0 = uncapped, internally clamped by spawner storage capacity) int burstCount float burstDelay float stackSpeedIncrease bool burstsUpdatePositionEveryBullet","title":"BurstData"},{"location":"api-reference/#bulletspawnerpreset-scriptableobject","text":"bool UseMain BulletMainData Main bool UseShape SpawnShapeData ShapeData bool UseBurstData BurstData BurstData bool UseModules List<IBaseBulletModule> BulletModules Apply at runtime with BulletSpawner.SetPreset(...) .","title":"BulletSpawnerPreset : ScriptableObject"},{"location":"api-reference/#bullet-data-model-bulletfurydata","text":"","title":"Bullet data model (Bulletfury.Data)"},{"location":"api-reference/#bulletcontainer-fields","text":"Identity: int Id Transform and orientation: float3 Position Quaternion Rotation Quaternion Direction float3 Forward float3 Right float3 Up Visual: Color Color Color StartColor float StartSize float CurrentSize Collision: float ColliderSize byte UseCapsule float CapsuleLength byte Collided Lifetime/state: float Lifetime float CurrentLifeSeconds float CurrentLifePercent byte Dead byte EndOfLife byte Waiting float TimeToWait Movement and gameplay: float Speed float CurrentSpeed float3 Velocity float3 Force float AngularVelocity float Damage Move-to-origin behavior: byte MovingToOrigin float3 OriginPosition float MoveToOriginTime float MoveToOriginCurrentTime float3 MoveToOriginStartPosition Method: void InitWithPositionRotationDirection(float3 position, Quaternion rotation, Quaternion direction)","title":"BulletContainer fields"},{"location":"api-reference/#data-enums","text":"SpawnDir : Shape , Randomised , Spherised , Direction , Point ForceSpace : Local , World CurveUsage : Lifetime , LoopedTime","title":"Data enums"},{"location":"api-reference/#event-types","text":"BulletSpawnedEvent : UnityEvent<int, BulletContainer> BulletDiedEvent : UnityEvent<int, BulletContainer, bool> BulletCancelledEvent : UnityEvent<int, BulletContainer, bool> BulletCollisionEvent : UnityEvent<BulletContainer, Transform>","title":"Event types"},{"location":"api-reference/#rendering-and-shared-render-data","text":"","title":"Rendering and shared render data"},{"location":"api-reference/#bulletrenderdata","text":"Public fields: Camera Camera Texture2D Texture bool Animated int Rows int Columns float PerFrameLength int Layer int Priority Public members: Material Material { get; } static void ResetMaterials() Material GetMaterial() void ReturnMaterial(Material material) void DisposeMaterials()","title":"BulletRenderData"},{"location":"api-reference/#sharedrenderdata","text":"BulletRenderData Data { get; } SharedRenderDataSO SharedDataSO { get; } (editor-only) Implicit conversions: SharedRenderData -> BulletRenderData BulletRenderData -> SharedRenderData SharedRenderDataSO -> SharedRenderData","title":"SharedRenderData"},{"location":"api-reference/#sharedrenderdataso-scriptableobject","text":"void SetData(BulletRenderData data) Implicit conversion: SharedRenderDataSO -> BulletRenderData","title":"SharedRenderDataSO : ScriptableObject"},{"location":"api-reference/#bulletrenderer-advanced-static-renderer-api","text":"Mesh Mesh { get; } static void Init() static void Dispose() static void Render(BulletRenderData data, NativeArray<Matrix4x4> transforms, NativeArray<float4> colors, NativeArray<float> times, int numBullets, Camera cam) Most users should not call BulletRenderer.Render(...) manually. Use BulletSpawner unless building a custom render path.","title":"BulletRenderer (advanced static renderer API)"},{"location":"api-reference/#built-in-free-modules-bulletfurymodules","text":"","title":"Built-in free modules (Bulletfury.Modules)"},{"location":"api-reference/#angularvelocitymodule-bulletmodule-iparallelbulletmodule","text":"Purpose: rotates bullet orientation over time. Serialized fields: AnimationCurve angularVelocity float scale","title":"AngularVelocityModule : BulletModule, IParallelBulletModule"},{"location":"api-reference/#bulletcolorovertimemodule-bulletmodule","text":"Purpose: applies gradient over life or looped time. Fields: Gradient colorOverTime","title":"BulletColorOverTimeModule : BulletModule"},{"location":"api-reference/#bulletdamageovertimemodule-ibulletmodule-iparallelbulletmodule","text":"Purpose: scales BulletContainer.Damage . Fields: AnimationCurve damageOverTime","title":"BulletDamageOverTimeModule : IBulletModule, IParallelBulletModule"},{"location":"api-reference/#bulletsizeovertimemodule-bulletmodule-iparallelbulletmodule","text":"Purpose: scales size over time. Fields: AnimationCurve sizeOverTime","title":"BulletSizeOverTimeModule : BulletModule, IParallelBulletModule"},{"location":"api-reference/#speedovertimemodule-bulletmodule-iparallelbulletmodule","text":"Purpose: scales current speed over time. Serialized fields: AnimationCurve speedOverTime float scale","title":"SpeedOverTimeModule : BulletModule, IParallelBulletModule"},{"location":"api-reference/#spawnerrotatemodule-ibulletspawnmodule","text":"Purpose: continuously rotates spawn basis at emit time. Serialized fields: float angularSpeed Public property: float CurrentAngle { get; }","title":"SpawnerRotateModule : IBulletSpawnModule"},{"location":"api-reference/#waittocontinuemodule-ibulletinitmodule","text":"Purpose: mark bullets as waiting after a configured pre-wait simulation time. Serialized fields: float timeToPlayBeforeWaiting Works with BulletSpawner.ActivateWaitingBullets() .","title":"WaitToContinueModule : IBulletInitModule"},{"location":"api-reference/#premium-add-on-modules-bulletfurymodules","text":"These types are in the premium package ( Bulletfury.Premium ) and are not part of the free module set.","title":"Premium add-on modules (Bulletfury.Modules)"},{"location":"api-reference/#aimedshotmodule-ibulletspawnmodule","text":"Re-aims spawn rotation toward a target before emission. Supports multiple aim modes via AimType : Instant , Linear , Slerp , SmoothDamp , Predicted . Public method: void SetTarget(Transform newTarget)","title":"AimedShotModule : IBulletSpawnModule"},{"location":"api-reference/#trackobjectmodule-bulletmodule","text":"Continuously steers active bullets toward a tracked transform over lifetime. Public properties: Transform ToTrack { get; } float TurnSpeed { get; }","title":"TrackObjectModule : BulletModule"},{"location":"api-reference/#bulletbouncemodule-ibulletdiemodule","text":"Intercepts collision death and reflects bullet direction/velocity for ricochet behavior. Can filter by collider tag and scale speed/lifetime per bounce.","title":"BulletBounceModule : IBulletDieModule"},{"location":"api-reference/#forceovertimemodule-bulletmodule-iparallelbulletmodule","text":"Applies curve-driven forces over bullet lifetime. Key options: ForceSpace space ( Local / World ) Vector3 scale AnimationCurve forceOverTimeX/Y/Z","title":"ForceOverTimeModule : BulletModule, IParallelBulletModule"},{"location":"api-reference/#sinwaveoffsetmodule-bulletmodule-iparallelbulletmodule","text":"Adds sinusoidal lateral offset to bullet trajectory over time. Key controls include amplitude, frequency, phase offset, direction invert, and amplitude curve.","title":"SinWaveOffsetModule : BulletModule, IParallelBulletModule"},{"location":"api-reference/#spawnfromtransformmodule-ibulletinitmodule","text":"Spawns bullets from a referenced transform and interpolates toward original spawn position.","title":"SpawnFromTransformModule : IBulletInitModule"},{"location":"api-reference/#subspawnermodule-ibulletdiemodule","text":"Emits configured sub-spawners on collision and/or end-of-life events. Uses SubSpawnerData[] payload configuration.","title":"SubSpawnerModule : IBulletDieModule"},{"location":"api-reference/#replaymodule-ibasebulletmodule","text":"Records BulletSpawner.SpawnerState snapshots over time for playback/rewind flows. Key methods: void RecordStep(BulletSpawner spawner, float deltaTime) void ResetTimeline() void PrepareForRewind(BulletSpawner spawner) void TrimFutureSteps() bool TryRewindBySeconds(float rewindSeconds, out float actualSecondsRewound) bool TryGetAppliedState(out BulletSpawner.SpawnerState state)","title":"ReplayModule : IBaseBulletModule"},{"location":"api-reference/#rewindmodule-ibasebulletmodule","text":"Applies rewind playback against a ReplayModule timeline. Key methods: void BeginRewind() void EndRewind() bool Rewind(BulletSpawner spawner, ReplayModule replayModule, float deltaTime)","title":"RewindModule : IBaseBulletModule"},{"location":"api-reference/#deterministicruntimemodule-ispawnerruntimemoduleprovider-ispawnerruntimemodule-ibulletinitmodule","text":"Installs deterministic random sampling/tick stepping into spawner runtime. Public members: ulong Tick { get; } float LastSimulationDeltaTime { get; } ISpawnerRuntimeModule CreateRuntimeModule() void OnRuntimeReset(Squirrel3 random) void OnSimulationStep(float deltaTime) float Sample(FloatOrRandom value, Squirrel3 random) object CaptureState() void RestoreState(object state) void Execute(ref BulletContainer container)","title":"DeterministicRuntimeModule : ISpawnerRuntimeModuleProvider, ISpawnerRuntimeModule, IBulletInitModule"},{"location":"api-reference/#subspawnerdata-premium-data-model","text":"bool emitOnCollide bool emitOnLifeEnd bool inheritRotation bool inheritColor BulletSpawner spawner","title":"SubSpawnerData (premium data model)"},{"location":"api-reference/#attributes-and-metadata","text":"","title":"Attributes and metadata"},{"location":"api-reference/#moduleperformanceimpactrating","text":"Low , Medium , High , VeryHigh","title":"ModulePerformanceImpactRating"},{"location":"api-reference/#moduleperformanceimpactattribute","text":"Constructors: ModulePerformanceImpactAttribute(ModulePerformanceImpactRating rating) ModulePerformanceImpactAttribute(ModulePerformanceImpactRating rating, string justification) Properties: ModulePerformanceImpactRating Rating { get; } string Justification { get; }","title":"ModulePerformanceImpactAttribute"},{"location":"api-reference/#moduledescriptionattribute","text":"Constructor: ModuleDescriptionAttribute(string description) Property: string Description { get; } Use these on custom modules to improve inspector discoverability and team readability.","title":"ModuleDescriptionAttribute"},{"location":"api-reference/#commonrandom-utility-apis","text":"These are public in the package and often useful in custom runtime/module code.","title":"Common/random utility APIs"},{"location":"api-reference/#commonfloatorrandomfloatorrandom","text":"float Value { get; } float GetValue(Squirrel3 rnd) Implicit conversion: FloatOrRandom -> float float -> FloatOrRandom","title":"Common.FloatOrRandom.FloatOrRandom"},{"location":"api-reference/#wayfarer_gamescommonfloatorrandomintorrandom","text":"int Value { get; } int GetValue(Squirrel3 rnd) Implicit conversion: IntOrRandom -> int int -> IntOrRandom","title":"Wayfarer_Games.Common.FloatOrRandom.IntOrRandom"},{"location":"api-reference/#commonsquirrel3","text":"Constructors: Squirrel3() Squirrel3(int seed) Static: Squirrel3 Instance State: readonly struct State void SetSeed(int seed) void ResetState() State CaptureState() void RestoreState(State state) Sampling: float Next() double NextDouble() Vector2 RandomPointInUnitCircle() float Range(float min, float max) double Range(double min, double max) int Range(int min, int max) bool Bool() bool Bool(float chance) bool Bool(double chance) Selection: T WeightedRandom<T>(Dictionary<T, float> items) where T : class T WeightedRandom<T>(List<T> items) where T : class, IWeightedItem T GetRandomElement<T>(IEnumerable<T> list, out int idx)","title":"Common.Squirrel3"},{"location":"api-reference/#commoniweighteditem","text":"float Weight { get; }","title":"Common.IWeightedItem"},{"location":"api-reference/#wayfarer_gamescommonquaternionutil","text":"Quaternion AngVelToDeriv(Quaternion current, Vector3 angVel) Vector3 DerivToAngVel(Quaternion current, Quaternion deriv) Quaternion IntegrateRotation(Quaternion rotation, Vector3 angularVelocity, float deltaTime) Quaternion SmoothDamp(Quaternion rot, Quaternion target, ref Quaternion deriv, float time, float deltaTime)","title":"Wayfarer_Games.Common.QuaternionUtil"},{"location":"api-reference/#low-leveladvanced-public-types","text":"","title":"Low-level/advanced public types"},{"location":"api-reference/#bulletjob-ijobparallelfor","text":"BulletJob is public, but primarily intended for internal scheduling from BulletSpawner . Public fields include bullet arrays, render output arrays, transform deltas, collision sizing, and feature toggles ( UseRotationForDirection , MoveWithTransform , RotateWithTransform ). Public method: void Execute(int index) Unless you are building a custom simulation runner, use BulletSpawner.UpdateAllBullets(...) rather than scheduling BulletJob yourself.","title":"BulletJob : IJobParallelFor"},{"location":"api-reference/#best-practices-and-pitfalls","text":"Keep module logic deterministic and side-effect free where possible. For IParallelBulletModule , do not call Unity object APIs ( Transform , scene queries, physics, object creation/destruction). Treat BulletContainer as mutable state for the current step only; initialize all values you depend on. Use TryGetModule<T> and null checks in gameplay code that supports optional module loadouts. Keep maxActiveBullets tuned; uncapped ( 0 ) can still hit internal limits depending on spawner capacity. Prefer circle colliders for throughput; capsule colliders are heavier. If using CaptureState/ApplyState , keep module composition stable between save/load to avoid semantic mismatches.","title":"Best practices and pitfalls"},{"location":"api-reference/#recommended-testing-checklist","text":"Verify FireMode.Automatic and FireMode.Manual behaviors independently. Validate module behavior with and without IParallelBulletModule . Test collision and end-of-life death paths separately (including custom IBulletDieModule cancellation). Test pause/resume ( SetSimulationPaused ) and waiting bullets ( ActivateWaitingBullets ). If you rely on replay/state restore, test deterministic capture/restore over multiple seconds under varying frame rates.","title":"Recommended testing checklist"},{"location":"paid-version/","text":"Support the Project \u00b6 If you're enjoying Bulletfury and want to unlock the full suite of advanced modules, check out the Pro version on the Asset Store. Why upgrade? \u00b6 The Pro version is designed to save you time. It includes pre-built modules for: Aimed Shots / Target Tracking Bouncing / Ricochet Force Over Time motion shaping Sin Wave Offset motion shaping Spawn From Transform origin control Sub-Spawners (bullets that spawn other bullets) Rewind / Replay Deterministic Runtime (stable seed/tick simulation) It's the same engine, just with more toys in the box. If the widget above does not load, open it here: Bulletfury on the Unity Asset Store Free vs Pro: What's the difference? \u00b6 First off, the core engine is exactly the same . Both versions use the same high-performance BulletSpawner and module system. We didn't cripple the free version, it is fully capable of handling thousands of bullets. The main difference: convenience \u00b6 The Pro version is basically a \"batteries included\" pack. It comes with advanced modules pre-built and tested, so you do not have to write them yourself. But here's the secret: You can build almost everything in the Pro version yourself using the Free version's module API. If you are comfortable with C#, the sky is the limit. Feature breakdown \u00b6 Feature Free Version Pro Version Core Engine Included Included Basic Modules (Speed, Size, Color, etc.) Included Included Aimed Shot Module Build it yourself Ready to use Track Object (Homing) Module Build it yourself Ready to use Bouncing / Ricochet Build it yourself Ready to use Force Over Time Module Build it yourself Ready to use Sin Wave Offset Module Build it yourself Ready to use Spawn From Transform Module Build it yourself Ready to use Sub-Spawners (Spawn on hit/death) Build it yourself Ready to use Rewind / Replay System Build it yourself Ready to use Deterministic Runtime Module Build it yourself Ready to use Which one is right for you? \u00b6 Stick with Free if: You are a hobbyist, a student, or a programmer who loves writing custom behavior. You want full control and do not mind building features yourself. Go Pro if: You are shipping on a timeline and want complex behaviors like homing missiles and ricochet patterns ready immediately.","title":"Paid Version"},{"location":"paid-version/#support-the-project","text":"If you're enjoying Bulletfury and want to unlock the full suite of advanced modules, check out the Pro version on the Asset Store.","title":"Support the Project"},{"location":"paid-version/#why-upgrade","text":"The Pro version is designed to save you time. It includes pre-built modules for: Aimed Shots / Target Tracking Bouncing / Ricochet Force Over Time motion shaping Sin Wave Offset motion shaping Spawn From Transform origin control Sub-Spawners (bullets that spawn other bullets) Rewind / Replay Deterministic Runtime (stable seed/tick simulation) It's the same engine, just with more toys in the box. If the widget above does not load, open it here: Bulletfury on the Unity Asset Store","title":"Why upgrade?"},{"location":"paid-version/#free-vs-pro-whats-the-difference","text":"First off, the core engine is exactly the same . Both versions use the same high-performance BulletSpawner and module system. We didn't cripple the free version, it is fully capable of handling thousands of bullets.","title":"Free vs Pro: What's the difference?"},{"location":"paid-version/#the-main-difference-convenience","text":"The Pro version is basically a \"batteries included\" pack. It comes with advanced modules pre-built and tested, so you do not have to write them yourself. But here's the secret: You can build almost everything in the Pro version yourself using the Free version's module API. If you are comfortable with C#, the sky is the limit.","title":"The main difference: convenience"},{"location":"paid-version/#feature-breakdown","text":"Feature Free Version Pro Version Core Engine Included Included Basic Modules (Speed, Size, Color, etc.) Included Included Aimed Shot Module Build it yourself Ready to use Track Object (Homing) Module Build it yourself Ready to use Bouncing / Ricochet Build it yourself Ready to use Force Over Time Module Build it yourself Ready to use Sin Wave Offset Module Build it yourself Ready to use Spawn From Transform Module Build it yourself Ready to use Sub-Spawners (Spawn on hit/death) Build it yourself Ready to use Rewind / Replay System Build it yourself Ready to use Deterministic Runtime Module Build it yourself Ready to use","title":"Feature breakdown"},{"location":"paid-version/#which-one-is-right-for-you","text":"Stick with Free if: You are a hobbyist, a student, or a programmer who loves writing custom behavior. You want full control and do not mind building features yourself. Go Pro if: You are shipping on a timeline and want complex behaviors like homing missiles and ricochet patterns ready immediately.","title":"Which one is right for you?"},{"location":"extending/write-your-own-modules/","text":"Write Your Own Modules \u00b6 So you want to go beyond the basics? Awesome! Bulletfury is designed to be extended, and writing your own modules is surprisingly easy. How it works \u00b6 Custom modules are just C# classes. You don't need to inherit from MonoBehaviour \u2014just implement one of the module interfaces, and Bulletfury will pick it up automatically. The Rules \u00b6 For your module to show up in the Inspector, it must be: [Serializable] A normal class (not abstract) Have a default constructor (which C# gives you for free usually) Choose your weapon (Interface) \u00b6 IBulletSpawnModule : Run this before a bullet is born. Good for changing where it spawns. IBulletInitModule : Run this once when a bullet is born. Good for setting initial stats. IBulletModule : Run this every frame . This is where the magic happens (movement, color, etc.). IBulletDieModule : Run this when a bullet hits something. Want bouncing bullets? This is the place. Example 1: Making bullets drift sideways \u00b6 Let's make a module that pushes bullets to the right over time. using System; using Bulletfury; using Bulletfury.Data; using UnityEngine; namespace MyGame.BulletModules { [Serializable] // We implement IParallelBulletModule to say \"this is safe to run on multiple threads!\" public class SideDriftModule : IBulletModule, IParallelBulletModule { [SerializeField] private float driftSpeed = 1f; public void Execute(ref BulletContainer container, float deltaTime) { // Move along the bullet's local right vector container.Position += container.Right * driftSpeed * deltaTime; } } } Example 2: Custom spawn offset \u00b6 Want to shift the spawn point a bit? using System; using Bulletfury; using UnityEngine; namespace MyGame.BulletModules { [Serializable] public class SpawnOffsetModule : IBulletSpawnModule { [SerializeField] private Vector3 localOffset = new Vector3(0.5f, 0f, 0f); public void Execute(ref Vector3 position, ref Quaternion rotation, float deltaTime) { position += localOffset; } } } Example 3: Ignoring certain colliders \u00b6 By default, bullets die when they hit anything. Let's change that! using System; using Bulletfury; using Bulletfury.Data; using UnityEngine; namespace MyGame.BulletModules { [Serializable] public class IgnoreTriggerDeathModule : IBulletDieModule { public IBulletDieModule.CollisionBehaviour Execute( ref BulletContainer container, bool isCollision, GameObject collidingObject) { // If we hit a \"TriggerOnly\" object, stay alive! if (isCollision && collidingObject != null && collidingObject.CompareTag(\"TriggerOnly\")) { return IBulletDieModule.CollisionBehaviour.StaysAlive; } // Otherwise, die as usual return IBulletDieModule.CollisionBehaviour.Dies; } } } Make it pretty in the Inspector \u00b6 You can add descriptions and performance warnings to help your team: [ModuleDescription(\"Makes bullets drift sideways.\")] [ModulePerformanceImpact(ModulePerformanceImpactRating.Low)] public class SideDriftModule : ... A note on performance (Parallel vs Main Thread) \u00b6 If you implement IParallelBulletModule , your code will run on worker threads. This is much faster , but it has rules: Don't touch Unity APIs (like transform , GameObject.Find , Physics ). Don't change global variables. Do stick to math and the BulletContainer data. If you need to touch Unity stuff, just implement IBulletModule (without IParallel... ) and it will run safely on the main thread. Controlling modules from code \u00b6 You can grab your modules at runtime to tweak them: if (spawner.TryGetModule<SideDriftModule>(out var drift)) { drift.driftSpeed = 5f; // Turbo drift! }","title":"Write Your Own Modules"},{"location":"extending/write-your-own-modules/#write-your-own-modules","text":"So you want to go beyond the basics? Awesome! Bulletfury is designed to be extended, and writing your own modules is surprisingly easy.","title":"Write Your Own Modules"},{"location":"extending/write-your-own-modules/#how-it-works","text":"Custom modules are just C# classes. You don't need to inherit from MonoBehaviour \u2014just implement one of the module interfaces, and Bulletfury will pick it up automatically.","title":"How it works"},{"location":"extending/write-your-own-modules/#the-rules","text":"For your module to show up in the Inspector, it must be: [Serializable] A normal class (not abstract) Have a default constructor (which C# gives you for free usually)","title":"The Rules"},{"location":"extending/write-your-own-modules/#choose-your-weapon-interface","text":"IBulletSpawnModule : Run this before a bullet is born. Good for changing where it spawns. IBulletInitModule : Run this once when a bullet is born. Good for setting initial stats. IBulletModule : Run this every frame . This is where the magic happens (movement, color, etc.). IBulletDieModule : Run this when a bullet hits something. Want bouncing bullets? This is the place.","title":"Choose your weapon (Interface)"},{"location":"extending/write-your-own-modules/#example-1-making-bullets-drift-sideways","text":"Let's make a module that pushes bullets to the right over time. using System; using Bulletfury; using Bulletfury.Data; using UnityEngine; namespace MyGame.BulletModules { [Serializable] // We implement IParallelBulletModule to say \"this is safe to run on multiple threads!\" public class SideDriftModule : IBulletModule, IParallelBulletModule { [SerializeField] private float driftSpeed = 1f; public void Execute(ref BulletContainer container, float deltaTime) { // Move along the bullet's local right vector container.Position += container.Right * driftSpeed * deltaTime; } } }","title":"Example 1: Making bullets drift sideways"},{"location":"extending/write-your-own-modules/#example-2-custom-spawn-offset","text":"Want to shift the spawn point a bit? using System; using Bulletfury; using UnityEngine; namespace MyGame.BulletModules { [Serializable] public class SpawnOffsetModule : IBulletSpawnModule { [SerializeField] private Vector3 localOffset = new Vector3(0.5f, 0f, 0f); public void Execute(ref Vector3 position, ref Quaternion rotation, float deltaTime) { position += localOffset; } } }","title":"Example 2: Custom spawn offset"},{"location":"extending/write-your-own-modules/#example-3-ignoring-certain-colliders","text":"By default, bullets die when they hit anything. Let's change that! using System; using Bulletfury; using Bulletfury.Data; using UnityEngine; namespace MyGame.BulletModules { [Serializable] public class IgnoreTriggerDeathModule : IBulletDieModule { public IBulletDieModule.CollisionBehaviour Execute( ref BulletContainer container, bool isCollision, GameObject collidingObject) { // If we hit a \"TriggerOnly\" object, stay alive! if (isCollision && collidingObject != null && collidingObject.CompareTag(\"TriggerOnly\")) { return IBulletDieModule.CollisionBehaviour.StaysAlive; } // Otherwise, die as usual return IBulletDieModule.CollisionBehaviour.Dies; } } }","title":"Example 3: Ignoring certain colliders"},{"location":"extending/write-your-own-modules/#make-it-pretty-in-the-inspector","text":"You can add descriptions and performance warnings to help your team: [ModuleDescription(\"Makes bullets drift sideways.\")] [ModulePerformanceImpact(ModulePerformanceImpactRating.Low)] public class SideDriftModule : ...","title":"Make it pretty in the Inspector"},{"location":"extending/write-your-own-modules/#a-note-on-performance-parallel-vs-main-thread","text":"If you implement IParallelBulletModule , your code will run on worker threads. This is much faster , but it has rules: Don't touch Unity APIs (like transform , GameObject.Find , Physics ). Don't change global variables. Do stick to math and the BulletContainer data. If you need to touch Unity stuff, just implement IBulletModule (without IParallel... ) and it will run safely on the main thread.","title":"A note on performance (Parallel vs Main Thread)"},{"location":"extending/write-your-own-modules/#controlling-modules-from-code","text":"You can grab your modules at runtime to tweak them: if (spawner.TryGetModule<SideDriftModule>(out var drift)) { drift.driftSpeed = 5f; // Turbo drift! }","title":"Controlling modules from code"},{"location":"getting-started/setup-and-first-spawn/","text":"Setup and First Spawn \u00b6 Let's get you up and running! This guide will take you from zero to seeing your first bullets flying across the screen. 1) Install the package \u00b6 First things first, let's get Bulletfury into your project. You can add the Git URL directly through the Unity Package Manager: Open the Package Manager ( Window > Package Manager ). Click the + button in the top left and select Add package from git URL... Enter the URL for the Bulletfury repository: https://github.com/WayfarerGames/bulletfury.git Click Add . Just a reminder: Bulletfury needs Unity 6+ and URP . It also relies on a few Unity packages like Burst and Mathematics, but those should install automatically. 2) Import the Sample Scene \u00b6 Before building your own spawner, the best way to understand Bulletfury is to look at the included examples! Open the Package Manager ( Window > Package Manager ). Find Bulletfury in the list of installed packages (make sure you're looking at \"Packages: In Project\"). Go to the Samples tab. Click Import next to the Demo Scene . Open the newly imported scene (usually under Assets/Samples/Bulletfury/ ) and press Play to see it in action! 3) Create a spawner object \u00b6 Now for the fun part! Create an empty GameObject in your scene. Add the BulletSpawner component to it. You'll see a few sections in the inspector: RenderData : How your bullets look. Bullet Settings : Basic bullet properties like speed and lifetime. Spawn Shape Data : Where bullets come from (circle, line, point, etc.). Burst Data : How many bullets fire at once. 4) Make it visible \u00b6 Before we can see anything, we need to tell Bulletfury how to draw the bullets. In RenderData : Assign your Main Camera . Assign a Texture2D for your bullet sprite. (Crucial! If you don't set this, nothing will show up.) Set the sorting Layer and Priority if you need them to appear on top of other things. Note: In the Inspector's RenderData section, you'll see a green circle in the bullet preview. This green circle shows the size of the bullet's collision area relative to the bullet sprite itself. Bulletfury collisions work natively with Unity's 2D colliders. 5) Configure the basics \u00b6 Let's set up a simple stream of bullets. In Bullet Settings : Set FireMode to Automatic so it starts firing right away. Check PlayOnEnable . Set FireRate to 0.1 (that's 10 shots per second). Set Lifetime to 1.5 seconds. Set Speed to 5 . In Spawn Shape Data (let's keep it simple for now): numPoints : 1 numPerSide : 1 radius : 0 spawnDir : Direction What does spawnDir do? This setting controls the initial direction your bullets will travel: Direction : Bullets fly straight up (relative to the spawner's rotation). Spherised : Bullets fly directly outward from the center point. Shape : Bullets fly perpendicular to the edge of the shape they spawned on. Point : Bullets fly outward towards the closest corner/point of the shape. Randomised : Bullets fly in a random direction within the defined directionArc . In Burst Data : burstCount : 1 delay : 0 6) Fire \u00b6 Hit Play Mode . If everything is set up right, you should see a stream of bullets shooting out! Scene View Tool: For rapid iteration without entering Play Mode, check the bottom left of your Scene window when the spawner is selected. You'll find a little widget to play, pause, and stop the selected spawner. This widget also displays the current and maximum bullet count , which is incredibly useful for testing performance and tuning density. Exploring Modules \u00b6 You might be wondering where settings like \"acceleration\", \"homing\", or \"color changes\" are. In Bulletfury, a lot of behavior is intentionally \"hidden\" behind Modules . Instead of one massive inspector with a hundred settings you aren't using, you snap on only the behaviors you need. We highly encourage you to check out the Free Modules page and experiment with adding them to your spawner to see what they do! Advanced Spawn Settings \u00b6 While the basics will get you started, the Spawn Shape Data has a lot of hidden power for making complex patterns without any extra modules: arc : Only spawn bullets along a specific angle (e.g. 180 for a half-circle). randomise / onEdge : Places bullets randomly within the shape or strictly on its outline. Grouping ( numPerGroup , groupRadius , groupDirection ) : Instead of single bullets, spawn them in clusters! Great for making thick walls of bullets. removeFromEdgePercent : Creates gaps at the corners of your shapes. Manual spawning \u00b6 Want to control when bullets fire? Set FireMode to Manual and use a script like this: using Bulletfury; using UnityEngine; public class ManualFireExample : MonoBehaviour { [SerializeField] private BulletSpawner spawner; private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { // Fire! spawner.Spawn(transform.position, transform.up, Time.deltaTime); } } } Here are the main methods you'll use: Spawn(Transform obj, float deltaTime) : Uses the transform's position and rotation. Spawn(Vector3 position, Vector3 up, float deltaTime) : Uses a specific position and direction. SpawnImmediate(...) : Fires instantly, ignoring the fire rate. Controlling the simulation \u00b6 You can also control the spawner at runtime: Play() / Stop() : Start or stop the automatic firing. SetSimulationPaused(bool paused) : Pause all bullets in mid-air. ClearBullets() : Remove all active bullets. ActivateWaitingBullets() : Release bullets that are waiting (great for complex patterns). Troubleshooting \u00b6 If things aren't working, check these common issues: No bullets visible? Did you assign a texture in RenderData ? Is the spawner object active? Bullets not firing in manual mode? Are you calling Spawn() ? Check if FireRate or Delay is preventing shots. Bullets vanish immediately? Check Lifetime in Bullet Settings . Check if they're hitting something immediately (collision settings).","title":"Setup and First Spawn"},{"location":"getting-started/setup-and-first-spawn/#setup-and-first-spawn","text":"Let's get you up and running! This guide will take you from zero to seeing your first bullets flying across the screen.","title":"Setup and First Spawn"},{"location":"getting-started/setup-and-first-spawn/#1-install-the-package","text":"First things first, let's get Bulletfury into your project. You can add the Git URL directly through the Unity Package Manager: Open the Package Manager ( Window > Package Manager ). Click the + button in the top left and select Add package from git URL... Enter the URL for the Bulletfury repository: https://github.com/WayfarerGames/bulletfury.git Click Add . Just a reminder: Bulletfury needs Unity 6+ and URP . It also relies on a few Unity packages like Burst and Mathematics, but those should install automatically.","title":"1) Install the package"},{"location":"getting-started/setup-and-first-spawn/#2-import-the-sample-scene","text":"Before building your own spawner, the best way to understand Bulletfury is to look at the included examples! Open the Package Manager ( Window > Package Manager ). Find Bulletfury in the list of installed packages (make sure you're looking at \"Packages: In Project\"). Go to the Samples tab. Click Import next to the Demo Scene . Open the newly imported scene (usually under Assets/Samples/Bulletfury/ ) and press Play to see it in action!","title":"2) Import the Sample Scene"},{"location":"getting-started/setup-and-first-spawn/#3-create-a-spawner-object","text":"Now for the fun part! Create an empty GameObject in your scene. Add the BulletSpawner component to it. You'll see a few sections in the inspector: RenderData : How your bullets look. Bullet Settings : Basic bullet properties like speed and lifetime. Spawn Shape Data : Where bullets come from (circle, line, point, etc.). Burst Data : How many bullets fire at once.","title":"3) Create a spawner object"},{"location":"getting-started/setup-and-first-spawn/#4-make-it-visible","text":"Before we can see anything, we need to tell Bulletfury how to draw the bullets. In RenderData : Assign your Main Camera . Assign a Texture2D for your bullet sprite. (Crucial! If you don't set this, nothing will show up.) Set the sorting Layer and Priority if you need them to appear on top of other things. Note: In the Inspector's RenderData section, you'll see a green circle in the bullet preview. This green circle shows the size of the bullet's collision area relative to the bullet sprite itself. Bulletfury collisions work natively with Unity's 2D colliders.","title":"4) Make it visible"},{"location":"getting-started/setup-and-first-spawn/#5-configure-the-basics","text":"Let's set up a simple stream of bullets. In Bullet Settings : Set FireMode to Automatic so it starts firing right away. Check PlayOnEnable . Set FireRate to 0.1 (that's 10 shots per second). Set Lifetime to 1.5 seconds. Set Speed to 5 . In Spawn Shape Data (let's keep it simple for now): numPoints : 1 numPerSide : 1 radius : 0 spawnDir : Direction What does spawnDir do? This setting controls the initial direction your bullets will travel: Direction : Bullets fly straight up (relative to the spawner's rotation). Spherised : Bullets fly directly outward from the center point. Shape : Bullets fly perpendicular to the edge of the shape they spawned on. Point : Bullets fly outward towards the closest corner/point of the shape. Randomised : Bullets fly in a random direction within the defined directionArc . In Burst Data : burstCount : 1 delay : 0","title":"5) Configure the basics"},{"location":"getting-started/setup-and-first-spawn/#6-fire","text":"Hit Play Mode . If everything is set up right, you should see a stream of bullets shooting out! Scene View Tool: For rapid iteration without entering Play Mode, check the bottom left of your Scene window when the spawner is selected. You'll find a little widget to play, pause, and stop the selected spawner. This widget also displays the current and maximum bullet count , which is incredibly useful for testing performance and tuning density.","title":"6) Fire"},{"location":"getting-started/setup-and-first-spawn/#exploring-modules","text":"You might be wondering where settings like \"acceleration\", \"homing\", or \"color changes\" are. In Bulletfury, a lot of behavior is intentionally \"hidden\" behind Modules . Instead of one massive inspector with a hundred settings you aren't using, you snap on only the behaviors you need. We highly encourage you to check out the Free Modules page and experiment with adding them to your spawner to see what they do!","title":"Exploring Modules"},{"location":"getting-started/setup-and-first-spawn/#advanced-spawn-settings","text":"While the basics will get you started, the Spawn Shape Data has a lot of hidden power for making complex patterns without any extra modules: arc : Only spawn bullets along a specific angle (e.g. 180 for a half-circle). randomise / onEdge : Places bullets randomly within the shape or strictly on its outline. Grouping ( numPerGroup , groupRadius , groupDirection ) : Instead of single bullets, spawn them in clusters! Great for making thick walls of bullets. removeFromEdgePercent : Creates gaps at the corners of your shapes.","title":"Advanced Spawn Settings"},{"location":"getting-started/setup-and-first-spawn/#manual-spawning","text":"Want to control when bullets fire? Set FireMode to Manual and use a script like this: using Bulletfury; using UnityEngine; public class ManualFireExample : MonoBehaviour { [SerializeField] private BulletSpawner spawner; private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { // Fire! spawner.Spawn(transform.position, transform.up, Time.deltaTime); } } } Here are the main methods you'll use: Spawn(Transform obj, float deltaTime) : Uses the transform's position and rotation. Spawn(Vector3 position, Vector3 up, float deltaTime) : Uses a specific position and direction. SpawnImmediate(...) : Fires instantly, ignoring the fire rate.","title":"Manual spawning"},{"location":"getting-started/setup-and-first-spawn/#controlling-the-simulation","text":"You can also control the spawner at runtime: Play() / Stop() : Start or stop the automatic firing. SetSimulationPaused(bool paused) : Pause all bullets in mid-air. ClearBullets() : Remove all active bullets. ActivateWaitingBullets() : Release bullets that are waiting (great for complex patterns).","title":"Controlling the simulation"},{"location":"getting-started/setup-and-first-spawn/#troubleshooting","text":"If things aren't working, check these common issues: No bullets visible? Did you assign a texture in RenderData ? Is the spawner object active? Bullets not firing in manual mode? Are you calling Spawn() ? Check if FireRate or Delay is preventing shots. Bullets vanish immediately? Check Lifetime in Bullet Settings . Check if they're hitting something immediately (collision settings).","title":"Troubleshooting"},{"location":"modules/free-modules/","text":"Free Modules \u00b6 Here's the toolbox you get with the free version of Bulletfury. These modules are the building blocks for creating all sorts of patterns. You can add any of these to your BulletSpawner component in the Inspector. How modules work \u00b6 Think of modules as little scripts that run at specific times in a bullet's life: Spawn Modules : Run before the bullet is created (to set position/rotation). Init Modules : Run once when the bullet is born. Update Modules : Run every frame while the bullet is alive. Die Modules : Run when the bullet hits something or expires. The Modules \u00b6 SpawnerRotateModule \u00b6 Make it spin! What it does : Rotates the spawner over time. Perfect for : Spirals, rotating fans, spinning rings. Key setting : angularSpeed (how fast it spins in degrees per second). SpeedOverTimeModule \u00b6 Faster! Slower! What it does : Changes the bullet's speed over its lifetime. Perfect for : Bullets that start slow and speed up, or pulse in speed. Key settings : Draw a curve for speed over time. AngularVelocityModule \u00b6 Curved shots What it does : Rotates the bullet's direction over time. Perfect for : Wavy patterns, boomerangs, or spiraling shots. Key settings : Draw a curve for rotation speed over time. BulletSizeOverTimeModule \u00b6 Grow and shrink What it does : Changes the bullet's size. Perfect for : Popping bullets into existence, or shrinking them as they fade out. Key settings : Draw a curve for size over time. BulletColorOverTimeModule \u00b6 Pretty colors What it does : Tints the bullet color over its life. Perfect for : Fading bullets out, or making them \"heat up\" as they travel. Key settings : Set a gradient for color over time. BulletDamageOverTimeModule \u00b6 Damage falloff What it does : Changes how much damage a bullet does based on how long it's been alive. Perfect for : Shotguns (high damage close up, low damage far away). Key settings : Draw a curve for damage multiplier. WaitToContinueModule \u00b6 Wait for it... What it does : Pauses bullets after a certain time, waiting for a signal to continue. Perfect for : \"Trace then release\" patterns, or freezing bullets in place before launching them at the player. How to use : Call spawner.ActivateWaitingBullets() in your code to release them. Want more? \u00b6 The Pro version includes even more modules like Homing/Tracking , Bouncing , Sub-Spawners , and Rewind/Replay . But don't worry, the free version is plenty powerful for most games! Premium-only Modules \u00b6 Premium-only: The modules in this section are part of Bulletfury Pro and are not included in the free package. AimedShotModule \u00b6 Smart spawn aiming What it does : Re-aims emission direction at a target before bullets spawn. Perfect for : Turrets, lock-on volleys, and predictive enemy shots. Why it's useful : Gives you precise control over how patterns track moving targets. TrackObjectModule \u00b6 Homing over lifetime What it does : Steers bullets toward a tracked target while they are alive. Perfect for : Homing missiles, pressure projectiles, and adaptive boss attacks. Why it's useful : Makes patterns feel reactive without rebuilding your whole spawner setup. BulletBounceModule \u00b6 Ping-pong chaos What it does : Lets bullets bounce off colliders instead of dying immediately. Perfect for : Arena patterns, enclosed boss rooms, and \"last bullet standing\" style attacks. Why it's useful : Creates dense patterns from fewer bullets. SubSpawnerModule \u00b6 Bullets that make bullets What it does : Spawns new bullets when parent bullets hit or expire. Perfect for : Splitting shots, chain reactions, and layered boss phases. Why it's useful : Great for complex patterns built from simple pieces. ForceOverTimeModule \u00b6 Add acceleration and drift What it does : Applies curve-driven force over time in local or world space. Perfect for : Wind-like motion, gravity drifts, and arcing trajectories. Why it's useful : Lets you shape complex motion without custom per-pattern scripts. SinWaveOffsetModule \u00b6 Wavy movement What it does : Offsets bullets sideways with sinusoidal motion over time. Perfect for : Serpentine shots, weaving walls, and rhythm-style bullet patterns. Why it's useful : Adds visual complexity while keeping spawn logic simple. SpawnFromTransformModule \u00b6 Proxy origin spawning What it does : Spawns bullets from a referenced transform, then moves them back to their original target position. Perfect for : Portal effects, offset emitters, and \"remote muzzle\" style weapons. Why it's useful : Decouples where bullets appear from where the spawner lives. ReplayModule + RewindModule \u00b6 Time tricks What it does : Records simulation snapshots, then rewinds through them in real time. Requires the DeterministicRuntimeModule Perfect for : Timeline attacks, deterministic pattern replays, and stylized time-control mechanics. Why it's useful : Makes advanced \"scripted chaos\" patterns much easier to produce. DeterministicRuntimeModule \u00b6 Stable simulation seeds What it does : Installs deterministic runtime sampling with seed/tick control. Perfect for : Replays, synchronized encounters, and repeatable debugging. Why it's useful : Helps make runs reproducible across sessions. Performance Tips \u00b6 Parallel is better : Most built-in modules run in parallel (on multiple CPU cores) automatically. Keep it simple : If you're spawning thousands of bullets, try to use simple curves.","title":"Free Modules"},{"location":"modules/free-modules/#free-modules","text":"Here's the toolbox you get with the free version of Bulletfury. These modules are the building blocks for creating all sorts of patterns. You can add any of these to your BulletSpawner component in the Inspector.","title":"Free Modules"},{"location":"modules/free-modules/#how-modules-work","text":"Think of modules as little scripts that run at specific times in a bullet's life: Spawn Modules : Run before the bullet is created (to set position/rotation). Init Modules : Run once when the bullet is born. Update Modules : Run every frame while the bullet is alive. Die Modules : Run when the bullet hits something or expires.","title":"How modules work"},{"location":"modules/free-modules/#the-modules","text":"","title":"The Modules"},{"location":"modules/free-modules/#spawnerrotatemodule","text":"Make it spin! What it does : Rotates the spawner over time. Perfect for : Spirals, rotating fans, spinning rings. Key setting : angularSpeed (how fast it spins in degrees per second).","title":"SpawnerRotateModule"},{"location":"modules/free-modules/#speedovertimemodule","text":"Faster! Slower! What it does : Changes the bullet's speed over its lifetime. Perfect for : Bullets that start slow and speed up, or pulse in speed. Key settings : Draw a curve for speed over time.","title":"SpeedOverTimeModule"},{"location":"modules/free-modules/#angularvelocitymodule","text":"Curved shots What it does : Rotates the bullet's direction over time. Perfect for : Wavy patterns, boomerangs, or spiraling shots. Key settings : Draw a curve for rotation speed over time.","title":"AngularVelocityModule"},{"location":"modules/free-modules/#bulletsizeovertimemodule","text":"Grow and shrink What it does : Changes the bullet's size. Perfect for : Popping bullets into existence, or shrinking them as they fade out. Key settings : Draw a curve for size over time.","title":"BulletSizeOverTimeModule"},{"location":"modules/free-modules/#bulletcolorovertimemodule","text":"Pretty colors What it does : Tints the bullet color over its life. Perfect for : Fading bullets out, or making them \"heat up\" as they travel. Key settings : Set a gradient for color over time.","title":"BulletColorOverTimeModule"},{"location":"modules/free-modules/#bulletdamageovertimemodule","text":"Damage falloff What it does : Changes how much damage a bullet does based on how long it's been alive. Perfect for : Shotguns (high damage close up, low damage far away). Key settings : Draw a curve for damage multiplier.","title":"BulletDamageOverTimeModule"},{"location":"modules/free-modules/#waittocontinuemodule","text":"Wait for it... What it does : Pauses bullets after a certain time, waiting for a signal to continue. Perfect for : \"Trace then release\" patterns, or freezing bullets in place before launching them at the player. How to use : Call spawner.ActivateWaitingBullets() in your code to release them.","title":"WaitToContinueModule"},{"location":"modules/free-modules/#want-more","text":"The Pro version includes even more modules like Homing/Tracking , Bouncing , Sub-Spawners , and Rewind/Replay . But don't worry, the free version is plenty powerful for most games!","title":"Want more?"},{"location":"modules/free-modules/#premium-only-modules","text":"Premium-only: The modules in this section are part of Bulletfury Pro and are not included in the free package.","title":"Premium-only Modules"},{"location":"modules/free-modules/#aimedshotmodule","text":"Smart spawn aiming What it does : Re-aims emission direction at a target before bullets spawn. Perfect for : Turrets, lock-on volleys, and predictive enemy shots. Why it's useful : Gives you precise control over how patterns track moving targets.","title":"AimedShotModule"},{"location":"modules/free-modules/#trackobjectmodule","text":"Homing over lifetime What it does : Steers bullets toward a tracked target while they are alive. Perfect for : Homing missiles, pressure projectiles, and adaptive boss attacks. Why it's useful : Makes patterns feel reactive without rebuilding your whole spawner setup.","title":"TrackObjectModule"},{"location":"modules/free-modules/#bulletbouncemodule","text":"Ping-pong chaos What it does : Lets bullets bounce off colliders instead of dying immediately. Perfect for : Arena patterns, enclosed boss rooms, and \"last bullet standing\" style attacks. Why it's useful : Creates dense patterns from fewer bullets.","title":"BulletBounceModule"},{"location":"modules/free-modules/#subspawnermodule","text":"Bullets that make bullets What it does : Spawns new bullets when parent bullets hit or expire. Perfect for : Splitting shots, chain reactions, and layered boss phases. Why it's useful : Great for complex patterns built from simple pieces.","title":"SubSpawnerModule"},{"location":"modules/free-modules/#forceovertimemodule","text":"Add acceleration and drift What it does : Applies curve-driven force over time in local or world space. Perfect for : Wind-like motion, gravity drifts, and arcing trajectories. Why it's useful : Lets you shape complex motion without custom per-pattern scripts.","title":"ForceOverTimeModule"},{"location":"modules/free-modules/#sinwaveoffsetmodule","text":"Wavy movement What it does : Offsets bullets sideways with sinusoidal motion over time. Perfect for : Serpentine shots, weaving walls, and rhythm-style bullet patterns. Why it's useful : Adds visual complexity while keeping spawn logic simple.","title":"SinWaveOffsetModule"},{"location":"modules/free-modules/#spawnfromtransformmodule","text":"Proxy origin spawning What it does : Spawns bullets from a referenced transform, then moves them back to their original target position. Perfect for : Portal effects, offset emitters, and \"remote muzzle\" style weapons. Why it's useful : Decouples where bullets appear from where the spawner lives.","title":"SpawnFromTransformModule"},{"location":"modules/free-modules/#replaymodule-rewindmodule","text":"Time tricks What it does : Records simulation snapshots, then rewinds through them in real time. Requires the DeterministicRuntimeModule Perfect for : Timeline attacks, deterministic pattern replays, and stylized time-control mechanics. Why it's useful : Makes advanced \"scripted chaos\" patterns much easier to produce.","title":"ReplayModule + RewindModule"},{"location":"modules/free-modules/#deterministicruntimemodule","text":"Stable simulation seeds What it does : Installs deterministic runtime sampling with seed/tick control. Perfect for : Replays, synchronized encounters, and repeatable debugging. Why it's useful : Helps make runs reproducible across sessions.","title":"DeterministicRuntimeModule"},{"location":"modules/free-modules/#performance-tips","text":"Parallel is better : Most built-in modules run in parallel (on multiple CPU cores) automatically. Keep it simple : If you're spawning thousands of bullets, try to use simple curves.","title":"Performance Tips"},{"location":"patterns/basic-patterns/","text":"Basic Patterns \u00b6 Ready to make some cool patterns? Here are a few recipes using just the free modules. Feel free to tweak the numbers and make them your own! 1. Straight Stream \u00b6 Tagline: The classic \"pew pew\" Great for basic enemies or player weapons. Bullet Settings: FireMode : Automatic FireRate : 0.1 (fast) Speed : 6 Lifetime : 2 Spawn Shape Data: numPoints : 1 spawnDir : Direction Modules: None needed! 2. Radial Burst \u00b6 Tagline: The \"shockwave\" Spawns a ring of bullets expanding outward. Bullet Settings: FireMode : Automatic (or Manual for explosions) FireRate : 1.0 (slow) Spawn Shape Data: numPoints : 24 (more points = smoother circle) radius : 0 arc : 360 spawnDir : Spherised (this makes them shoot outward from the center) Burst Data: burstCount : 1 (single ring) Try 3 with a small burstDelay for a triple-ring effect! 3. Rotating Spiral \u00b6 Tagline: The \"bullet hell staple\" A single stream that spins around, creating a beautiful spiral. Base Settings: Start with the Straight Stream above. Add Module: SpawnerRotateModule angularSpeed : 120 (spin speed) Polish: Add SpeedOverTimeModule to make the spiral expand faster or slower as it goes out. Add BulletColorOverTimeModule to make it look hypnotic. 4. Wave Stream \u00b6 Tagline: The \"wobbly laser\" A stream of bullets that speeds up and slows down, creating a wave effect. Base Settings: Start with the Straight Stream . Add Module: SpeedOverTimeModule Curve : Make it go up and down (e.g., 0.8 -> 1.2 -> 0.8). Mode : Time (loops the curve) Time : 0.8 (how fast the wave pulses) 5. Hold & Release \u00b6 Tagline: The \"wait for it...\" Spawn bullets, freeze them in place, then launch them all at once. Setup: Add WaitToContinueModule . Set timeToPlayBeforeWaiting to a small number (like 0.5 ) so they fly out a bit and then stop. Trigger: Call this in your code when you're ready to fire: spawner.ActivateWaitingBullets(); Great for: Boss attacks where you want to telegraph the pattern before it becomes dangerous. 6. Shotgun Blast \u00b6 Tagline: The \"boomstick\" A random spread of bullets in a cone. Bullet Settings: FireMode : Manual Spawn Shape Data: numPoints : 10 spawnDir : Randomised directionArc : 30 (how wide the spread is) randomise : true Trigger: if (Input.GetMouseButtonDown(0)) spawner.Spawn(transform, Time.deltaTime); Tuning Tips \u00b6 Too dense? Lower numPoints or increase FireRate (higher number = slower fire). Too slow? Increase Speed . Laggy? Reduce the number of modules or total bullet count. Colliders : Use Circle colliders for best performance.","title":"Basic Patterns"},{"location":"patterns/basic-patterns/#basic-patterns","text":"Ready to make some cool patterns? Here are a few recipes using just the free modules. Feel free to tweak the numbers and make them your own!","title":"Basic Patterns"},{"location":"patterns/basic-patterns/#1-straight-stream","text":"Tagline: The classic \"pew pew\" Great for basic enemies or player weapons. Bullet Settings: FireMode : Automatic FireRate : 0.1 (fast) Speed : 6 Lifetime : 2 Spawn Shape Data: numPoints : 1 spawnDir : Direction Modules: None needed!","title":"1. Straight Stream"},{"location":"patterns/basic-patterns/#2-radial-burst","text":"Tagline: The \"shockwave\" Spawns a ring of bullets expanding outward. Bullet Settings: FireMode : Automatic (or Manual for explosions) FireRate : 1.0 (slow) Spawn Shape Data: numPoints : 24 (more points = smoother circle) radius : 0 arc : 360 spawnDir : Spherised (this makes them shoot outward from the center) Burst Data: burstCount : 1 (single ring) Try 3 with a small burstDelay for a triple-ring effect!","title":"2. Radial Burst"},{"location":"patterns/basic-patterns/#3-rotating-spiral","text":"Tagline: The \"bullet hell staple\" A single stream that spins around, creating a beautiful spiral. Base Settings: Start with the Straight Stream above. Add Module: SpawnerRotateModule angularSpeed : 120 (spin speed) Polish: Add SpeedOverTimeModule to make the spiral expand faster or slower as it goes out. Add BulletColorOverTimeModule to make it look hypnotic.","title":"3. Rotating Spiral"},{"location":"patterns/basic-patterns/#4-wave-stream","text":"Tagline: The \"wobbly laser\" A stream of bullets that speeds up and slows down, creating a wave effect. Base Settings: Start with the Straight Stream . Add Module: SpeedOverTimeModule Curve : Make it go up and down (e.g., 0.8 -> 1.2 -> 0.8). Mode : Time (loops the curve) Time : 0.8 (how fast the wave pulses)","title":"4. Wave Stream"},{"location":"patterns/basic-patterns/#5-hold-release","text":"Tagline: The \"wait for it...\" Spawn bullets, freeze them in place, then launch them all at once. Setup: Add WaitToContinueModule . Set timeToPlayBeforeWaiting to a small number (like 0.5 ) so they fly out a bit and then stop. Trigger: Call this in your code when you're ready to fire: spawner.ActivateWaitingBullets(); Great for: Boss attacks where you want to telegraph the pattern before it becomes dangerous.","title":"5. Hold &amp; Release"},{"location":"patterns/basic-patterns/#6-shotgun-blast","text":"Tagline: The \"boomstick\" A random spread of bullets in a cone. Bullet Settings: FireMode : Manual Spawn Shape Data: numPoints : 10 spawnDir : Randomised directionArc : 30 (how wide the spread is) randomise : true Trigger: if (Input.GetMouseButtonDown(0)) spawner.Spawn(transform, Time.deltaTime);","title":"6. Shotgun Blast"},{"location":"patterns/basic-patterns/#tuning-tips","text":"Too dense? Lower numPoints or increase FireRate (higher number = slower fire). Too slow? Increase Speed . Laggy? Reduce the number of modules or total bullet count. Colliders : Use Circle colliders for best performance.","title":"Tuning Tips"}]}